// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------// Render Tools// Author: Brennan Chapman// Version: 1.1//// Provides methods for rendering through a socket for Qube//// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------var that = this;if (true) {    RenderTools = (function () {        var scriptName = "RenderTools.jsx";        return {};    }());    // Open a project    RenderTools.openProject = function(projectPath) {        try {            app.openFast(File(projectPath));        } catch(error) {            that.log_file.writeln("ERROR: Unable to open project.\n" + error);            "Error loading project.";        }        "Project Loaded";    };    // Render all items queue in the render queue    RenderTools.renderQueued = function() {        try {            if (app.preferences.havePref("Misc Section", "Play sound when render finishes")) {                saved_sound_setting = app.preferences.getPrefAsLong("Misc Section", "Play sound when render finishes");            } else {                saved_sound_setting = 1;            }            app.preferences.savePrefAsLong("Misc Section", "Play sound when render finishes", 0);            app.project.renderQueue.render(true);            app.preferences.savePrefAsLong("Misc Section", "Play sound when render finishes", saved_sound_setting);            "Project Rendered";                        // Clean up the renderQueue so there aren't hundreds of items            for (var i=1; i<=app.project.renderQueue.items.length; i++) {                var rqItem = app.project.renderQueue.items[i];                if (rqItem.status === RQItemStatus.DONE) {                    rqItem.remove();                }            }                    } catch(error) {            that.log_file.writeln("ERROR: Unable to render.\n" + error.toString() + "\nFile: " + error.file + "\nLine: " + error.line);            "ERROR";        }    };    RenderTools.setMultiprocessing = function(enabled, ramPerCPU) {        enabled = Boolean(enabled);        ramPerCPU = parseInt(ramPerCPU);        var MPEnabled = 0;        if (enabled) { MPEnabled = 1; }        app.preferences.savePrefAsLong("MP - CS5 - 4", "MP - Enable", MPEnabled)        that.log_file.writeln("INFO:MPEnabled \n" + MPEnabled);                /*Ram indexes based on multiprocessing prefereces file. Indexes are offset by -1.            "MP - Allocation Per Background Process Preset I" = "0.750000"            "MP - Allocation Per Background Process Preset II" = "1.000000"            "MP - Allocation Per Background Process Preset III" = "1.500000"            "MP - Allocation Per Background Process Preset IV" = "2.000000"            "MP - Allocation Per Background Process Preset V" = "3.000000"        */        var MPRAMIndex = 0;        switch (ramPerCPU) {        case .75:            var MPRAMIndex = 0;            break;        case 1:            var MPRAMIndex = 1;            break;        case 1.5:            var MPRAMIndex = 2;            break;        case 2:            var MPRAMIndex = 3;            break;        case 3:            var MPRAMIndex = 4;            break;        default:            var MPRAMIndex = 3;            break;       }        app.preferences.savePrefAsLong("MP - CS5 - 4", "MP - Allocation Per Background Process Index", MPRAMIndex)        that.log_file.writeln("INFO:MPRAMIndex \n" + MPRAMIndex);        "Multiprocessing Setup";    }    RenderTools.loadPathConvert = function () {        // Read in the list of renderMounts            // Load the renderMounts file        path = "~/.renderMounts";        f = new File(path);        mounts = [];        if (f.exists) {            f.open('r');            data = f.read();            f.close();            // Ignore commented lines            lines = data.split("\n");            for (var i=0; i<lines.length; i++) {                if (lines[i].charAt(0) != "#" && lines[i].length > 1) {                    that.log_file.writeln("renderMount: " + lines[i]);                    mounts.push(lines[i]);                }            }        }        return mounts;    }    RenderTools.pathConvert = function(value, mounts) {        // pathConvert the input string        result = value.toString();        for (var i=0; i<mounts.length; i++) {            try {                // Separate the mount point                // [0] AFP Mount URL [1] Normal Mount Path [2]Background Mount Path                            mount = mounts[i].split(",");                result = result.replace(mount[1], mount[2]);                that.log_file.writeln("CONVERT: " + value.toString() + " -> " + result);            } catch(error) {                that.log_file.writeln("ERROR: Unable to convert paths.");            }        }                return result      }    RenderTools.setRenderQuality = function (qualityString) {        var qualityString = "Low";        var quality;        if (qualityString === "High") {            quality = 3;        } else if (qualityString === "Medium") {            quality = 2;        } else if (qualityString === "Low") {            quality = 1;        }                try {            var proj = app.project;            // Get the control comp            var controlComp;            for (var i=1; i<=proj.items.length; i++) {                if (app.project.items[i].name == "_Global_Controls") {                    $.writeln("Found comp");                    controlComp = proj.items[i];                }            }            // Get the Render Quality Layer            var qualityLayer;            for (var l=1; l<=controlComp.layers.length; l++) {                if (controlComp.layers[l].name == "RenderQuality") {                    $.writeln("Found layer");                    qualityLayer = controlComp.layers[l];                }            }            //Set the quality            qualityLayer.property("Effects").property("RenderQuality").property("Slider").setValue(quality);         } catch(error) {            that.log_file.writeln("WARNING: Unable to set render quality.");        }    }    // Setup the render queue    RenderTools.setupSegment = function(startFrame, endFrame, rqIndex) {        // ADD THESE FEATURES        //      Ignore skip existing files error        app.beginUndoGroup("Setup RenderQueue for render");        var errors = [];        // Make sure the rqItem exists        try {            var rqItem = app.project.renderQueue.item(parseInt(rqIndex));        } catch (error) {            errors.push("Render Queue item doesn't exist: " + rqIndex + "\n" + error.toString())        };        // Check for problematic render queue item statuses        if (errors.length == 0) {            if (rqItem.status == RQItemStatus.DONE) {                errors.push("Render Queue item status is done. Needs to be queued.");            } else if (rqItem.status == RQItemStatus.NEEDS_OUTPUT) {                errors.push("Render Queue item needs output.");            } else if (rqItem.status == RQItemStatus.USER_STOPPED) {                errors.push("Render Queue item status is user stopped. Needs to be queued.");            } else if (rqItem.status == RQItemStatus.ERR_STOPPED) {                errors.push("Render Queue item status is error stopped. Needs to be queued.");            };        };        // Set up the start and end frames        var start_time = rqItem.timeSpanStart;        var end_time   = rqItem.timeSpanStart + rqItem.timeSpanDuration;        var compStartFrame = rqItem.comp.displayStartTime / rqItem.comp.frameDuration;        var compEndFrame = rqItem.comp.duration / rqItem.comp.frameDuration - 1;        if (startFrame) {            if (startFrame < compStartFrame || startFrame > compEndFrame) {                errors.push("Start Frame (" + startFrame + ") out of range (" + compStartFrame + "-" + compEndFrame + ")");            };            start_time = -rqItem.comp.displayStartTime + ((parseInt(startFrame,10) - app.project.displayStartFrame) * rqItem.comp.frameDuration);        };        if (endFrame) {            if (endFrame < compStartFrame || endFrame > compEndFrame) {                errors.push("End Frame (" + endFrame + ") out of range (" + compStartFrame + "-" + compEndFrame + ")");            };            var end_frame_plus_one = parseInt(endFrame,10) + 1.0 - app.project.displayStartFrame;            end_time = -rqItem.comp.displayStartTime + (end_frame_plus_one * rqItem.comp.frameDuration);        };        // Path Convert the output paths        that.log_file.writeln("INFO: Converting Output Paths");        mounts = RenderTools.loadPathConvert();        if (mounts.length > 0) {            if (errors.length == 0) {                for (var o=1; o<=rqItem.outputModules.length; o++) {                    var outputPath = rqItem.outputModules[o].file.fsName;                    var newOutputPath = RenderTools.pathConvert(outputPath, mounts);                    var newOutputFile = new File(newOutputPath)                    rqItem.outputModules[o].file = newOutputFile;                }            }        }        if (errors.length == 0) {            // Turn off all other rq items            for (var r=1; r<=app.project.renderQueue.numItems; r++) {                try {                    app.project.renderQueue.item(r).render = false;                } catch (error) {                    continue;                };            };            // If the rq index has already been rendered once, create a duplicate to render from.            var origRQItem = rqItem;            rqItem = origRQItem.duplicate();            origRQItem.render = false;            // Get the output files            var sequence = true;            for (var o=1; o<=origRQItem.outputModules.length; o++) {                // Prefix the output file path of the original because multiple rq items can't have the same output file.                outputFile = origRQItem.outputModule(o).file;                if (outputFile.fsName.substr(0, 5) == "/RNDR") {                    outputFile = new File(outputFile.fsName.slice(5));                } else {                    origRQItem.outputModule(o).file = new File("/RNDR" + outputFile.fsName);                }                if (/[^.]+$/.exec(outputFile.fsName) === "mov") {                    sequence = false;                }                rqItem.outputModule(o).file = outputFile;            }            // Make sure skipFrames is turned off for non-sequences            if (!sequence) {                rqItem.skipFrames = false;            }            rqItem.render = true;            origRQItem.render = false;            rqItem.logType = LogType.ERRORS_AND_PER_FRAME_INFO;        };        if (errors.length == 0) {            rqItem.timeSpanStart = start_time;            rqItem.timeSpanDuration = end_time - start_time;            outputs = [];            for (var o=1; o<=rqItem.outputModules.length; o++) {                outputs.push(rqItem.outputModule(o).file.fsName);            };        };        app.endUndoGroup();        if (errors.length > 0) {            for (var e=0; e<errors.length; e++) {                that.log_file.writeln("ERROR: " + errors[e]);            };            "ERROR";        } else {            "Testing";            //outputs.toString();        };    }    }