// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------// Elevate Qube Submission Prep Script// Author: Brennan Chapman// Version: 1.0// Date: 4/8/2011//// Gathers all of the relevate info about a project into a JSON object.// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------// #include '/Volumes/theGrill/Resource_Library/Art_Anim/Scripts/After_Effects/getDataFile.jsx';// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------// Qube Functions// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------function getQubeguiPath(){    var qubeguiPath = "";    // Get from preferences    if (app.settings.haveSetting("Qube", "QubeGUI_path")) {        qubeguiPath = app.settings.getSetting("Qube", "QubeGUI_path");    }     // if path invalid, then prompt for path    var qubeguiFile = new File(qubeguiPath);    if (!qubeguiFile.exists) {        qubeguiPath = setQubeguiPath()    }    writeLn("QubeGUI path: "+qubeguiPath);    return qubeguiPath;}// See same function in Qube_SetPath.jsxfunction setQubeguiPath(){    var qubeguiPath = "";    // if not have QubeGUI path, then open dialog to browse to it    if (system.osName == "MacOS") { // note: using a prompt since the MacOS filebrowser cannot seem to select .app files        qubeguiPath = prompt("Enter the path to the QubeGUI", "/Applications/pfx/qube/qube.app");        // (For OSX) if selected app ends with .app, then append the part internal to the app        if (qubeguiPath.indexOf('.app') == qubeguiPath.length - 4) { // if .app at end            qubeguiPath += '/Contents/MacOS/qube';        }    }    else {        var qubeguiPathObj = File.openDialog("Enter the path to the QubeGUI", "");        if (qubeguiPathObj != null) {            qubeguiPath = qubeguiPathObj.fsName;        }    }    if (qubeguiPath != "") {        alert("Storing 'QubeGUI_path' as '"+qubeguiPath+"'");        app.settings.saveSetting("Qube", "QubeGUI_path", qubeguiPath);    }    return qubeguiPath;}// Check for potential conflictsfunction checkProj() {    var warnings = ["Continue With Warnings?"]    rq = app.project.renderQueue;    for (var r=1; r<=app.project.renderQueue.items.length; r++) {        var frameRate = rq.items[r].comp.frameRate.toFixed(2);        var startTime = parseFloat(timeToCurrentFormat(rq.items[r].timeSpanStart, frameRate)).toFixed(0);        var duration = parseFloat(timeToCurrentFormat(rq.items[r].timeSpanDuration, frameRate)).toFixed(0);        var stopTime = parseFloat(parseInt(startTime) + parseInt(duration));        var compDuration = parseFloat(timeToCurrentFormat(rq.items[r].comp.duration, rq.items[r].comp.frameRate)).toFixed(0);                // Check if rendering the work area or the full comp        if (startTime != 0 || stopTime < compDuration) {            var message = "RQ Item " + r + " only rendering the work area (" + startTime + "-" + stopTime + ")";            warnings[warnings.length] = message;        }    }    return warnings;}function sendToQube() {    var qubeguiPath = getQubeguiPath();        // Submit each queue rq item separately    var rq = app.project.renderQueue;	var rqi;	// the items are indexed from 1 to numItems.    for (var i = rq.numItems; i >= 1; i--) {        rqi = rq.item(i);        if (rqi.status == RQItemStatus.QUEUED ) {  // alt?: cur_item.render == true            // status options: QUEUED, UNQUEUED, NEEDS_OUTPUT, WILL_CONTINUE                                    // construct commands            var args = " --submitDict \"{"+                                "'prototype':'AERenderX', "+                                "'name':'" + proj.file.fsName + "',"+                                "'package':{"+                                    "'simpleCmdType':'AERenderX',"+                                    "'projectPath':'"+proj.file.fsName+"',"+                                    "'rqIndex':'" + i + "',"+                                "}}\"";            var cmd = "";            if (system.osName == "MacOS") {                cmd = qubeguiPath + args + " >& /dev/null &";            }            else {                cmd = "\"" + qubeguiPath + "\"" + args;  // NOTE: using "start" does not work here            }            writeLn(cmd);            var cmdOutput = system.callSystem(cmd);            writeLn(cmdOutput);        }    }}// Go!if (app.project.file == null) {    alert("ERROR: Unable send to Qube. Please Save Project First.");} else {    getDataFileScript = new File("/Volumes/theGrill/Resource_Library/Art_Anim/Scripts/After_Effects/getDataFile.jsx");    if (app.project.renderQueue.numItems < 1) {        alert("ERROR: No items to render in the render queue.");    }    $.evalFile(getDataFileScript);        // Switch the timecode type to frames    currTimeFormat = app.project.timecodeDisplayType;    app.project.timecodeDisplayType = TimecodeDisplayType.FRAMES;            var warnings = checkProj();    var go = true    if (warnings.length > 1) {        var result = confirm(warnings.join("\n"), false, "Continue?");        if (result == false) {            go = false;        }    }    if (go) {        sendToQube();    } else {        clearOutput();        writeLn("Submission Cancelled.")    }        // Switch the timecode type back to original format    app.project.timecodeDisplayType = currTimeFormat;}