#!/usr/bin/python

################################################################################
#
# Image Sequence Utilities
# Author: Brennan Chapman
#
# Scans current directory for image sequences. You can then gather information
# about each image sequence or delete frames. If the terminal supports it, the
# valid sequences are displayed in green, and invalid sequences in red.
#
# Prerequisites:
# PIL - Python Imaging Library - http://www.pythonware.com/products/pil/#
#
# Exit Codes:
# 0 - No Errors
# 1 - Corrupt Frames Found
# 2 - Corrupt Frames Deleted
#
################################################################################

import os, sys, re, commands, ConfigParser, math
from optparse import OptionParser
from PIL import Image
#from sets import Set

################################################################################
# Sequence Data CLASS
################################################################################

class SeqData:
    def __init__(self, searchDirectory):
        self.directory = searchDirectory
        self.files = []
        self.frameSets = []
        self.folders = []
        self.currFS = ""
        self.currFolder = ""


################################################################################
# PROGRESS BAR CLASS
################################################################################

class ProgressBar:
    def __init__(self, duration):
        self.duration = duration
        self.prog_bar = '[]'
        self.fill_char = '#'
        self.width = getTerminalSize()[0] - 15
        self.msg = ""
        self.__update_amount(0)
    
    def __update_amount(self, new_amount):
        percent_done = int(round((new_amount / 100.0) * 100.0))
        all_full = self.width - 40
        num_hashes = int(round((percent_done / 100.0) * all_full))
        self.prog_bar = self.msg + '[' + self.fill_char * num_hashes + ' ' * (all_full - num_hashes) + ']'
        pct_place = (len(self.prog_bar) / 2) - len(str(percent_done)) + (len(self.msg) / 2)
        pct_string = '%i%%' % percent_done
        self.prog_bar = self.prog_bar[0:pct_place] + \
            (pct_string + self.prog_bar[pct_place + len(pct_string):])
        
    def update_time(self, elapsed_secs):
        sys.stdout.write('\r')
        self.__update_amount((elapsed_secs / float(self.duration)) * 100.0)
        self.prog_bar += '  %d/%s' % (elapsed_secs, self.duration)
        sys.stdout.write(str(self.prog_bar))
        
    def clear_progress(self):
        sys.stdout.write('\r')
        sys.stdout.write(' ' * len(self.prog_bar))
        sys.stdout.write('\r')
        #sys.stdout.write('chr(0x08)' * len(str(self.prog_bar)))
        
    def __str__(self):
        return str(self.prog_bar)

################################################################################
# TERMINAL CONTROLLER CLASS
################################################################################

class TerminalController:
    """
    A class that can be used to portably generate formatted output to
    a terminal.  
    
    `TerminalController` defines a set of instance variables whose
    values are initialized to the control sequence necessary to
    perform a given action.  These can be simply included in normal
    output to the terminal:

        >>> term = TerminalController()
        >>> print 'This is '+term.GREEN+'green'+term.NORMAL

    Alternatively, the `render()` method can used, which replaces
    '${action}' with the string required to perform 'action':

        >>> term = TerminalController()
        >>> print term.render('This is ${GREEN}green${NORMAL}')

    If the terminal doesn't support a given action, then the value of
    the corresponding instance variable will be set to ''.  As a
    result, the above code will still work on terminals that do not
    support color, except that their output will not be colored.
    Also, this means that you can test whether the terminal supports a
    given action by simply testing the truth value of the
    corresponding instance variable:

        >>> term = TerminalController()
        >>> if term.CLEAR_SCREEN:
        ...     print 'This terminal supports clearning the screen.'

    Finally, if the width and height of the terminal are known, then
    they will be stored in the `COLS` and `LINES` attributes.
    """
    # Cursor movement:
    BOL = ''             #: Move the cursor to the beginning of the line
    UP = ''              #: Move the cursor up one line
    DOWN = ''            #: Move the cursor down one line
    LEFT = ''            #: Move the cursor left one char
    RIGHT = ''           #: Move the cursor right one char

    # Deletion:
    CLEAR_SCREEN = ''    #: Clear the screen and move to home position
    CLEAR_EOL = ''       #: Clear to the end of the line.
    CLEAR_BOL = ''       #: Clear to the beginning of the line.
    CLEAR_EOS = ''       #: Clear to the end of the screen

    # Output modes:
    BOLD = ''            #: Turn on bold mode
    BLINK = ''           #: Turn on blink mode
    DIM = ''             #: Turn on half-bright mode
    REVERSE = ''         #: Turn on reverse-video mode
    NORMAL = ''          #: Turn off all modes

    # Cursor display:
    HIDE_CURSOR = ''     #: Make the cursor invisible
    SHOW_CURSOR = ''     #: Make the cursor visible

    # Terminal size:
    COLS = None          #: Width of the terminal (None for unknown)
    LINES = None         #: Height of the terminal (None for unknown)

    # Foreground colors:
    BLACK = BLUE = GREEN = CYAN = RED = MAGENTA = YELLOW = WHITE = ''
    
    # Background colors:
    BG_BLACK = BG_BLUE = BG_GREEN = BG_CYAN = ''
    BG_RED = BG_MAGENTA = BG_YELLOW = BG_WHITE = ''
    
    _STRING_CAPABILITIES = """
    BOL=cr UP=cuu1 DOWN=cud1 LEFT=cub1 RIGHT=cuf1
    CLEAR_SCREEN=clear CLEAR_EOL=el CLEAR_BOL=el1 CLEAR_EOS=ed BOLD=bold
    BLINK=blink DIM=dim REVERSE=rev UNDERLINE=smul NORMAL=sgr0
    HIDE_CURSOR=cinvis SHOW_CURSOR=cnorm""".split()
    _COLORS = """BLACK BLUE GREEN CYAN RED MAGENTA YELLOW WHITE""".split()
    _ANSICOLORS = "BLACK RED GREEN YELLOW BLUE MAGENTA CYAN WHITE".split()

    def __init__(self, term_stream=sys.stdout):
        """
        Create a `TerminalController` and initialize its attributes
        with appropriate values for the current terminal.
        `term_stream` is the stream that will be used for terminal
        output; if this stream is not a tty, then the terminal is
        assumed to be a dumb terminal (i.e., have no capabilities).
        """
        # Curses isn't available on all platforms
        try: import curses
        except: return

        # If the stream isn't a tty, then assume it has no capabilities.
        if not term_stream.isatty(): return

        # Check the terminal type.  If we fail, then assume that the
        # terminal has no capabilities.
        try: curses.setupterm()
        except: return

        # Look up numeric capabilities.
        self.COLS = curses.tigetnum('cols')
        self.LINES = curses.tigetnum('lines')
        
        # Look up string capabilities.
        for capability in self._STRING_CAPABILITIES:
            (attrib, cap_name) = capability.split('=')
            setattr(self, attrib, self._tigetstr(cap_name) or '')

        # Colors
        set_fg = self._tigetstr('setf')
        if set_fg:
            for i,color in zip(range(len(self._COLORS)), self._COLORS):
                setattr(self, color, curses.tparm(set_fg, i) or '')
        set_fg_ansi = self._tigetstr('setaf')
        if set_fg_ansi:
            for i,color in zip(range(len(self._ANSICOLORS)), self._ANSICOLORS):
                setattr(self, color, curses.tparm(set_fg_ansi, i) or '')
        set_bg = self._tigetstr('setb')
        if set_bg:
            for i,color in zip(range(len(self._COLORS)), self._COLORS):
                setattr(self, 'BG_'+color, curses.tparm(set_bg, i) or '')
        set_bg_ansi = self._tigetstr('setab')
        if set_bg_ansi:
            for i,color in zip(range(len(self._ANSICOLORS)), self._ANSICOLORS):
                setattr(self, 'BG_'+color, curses.tparm(set_bg_ansi, i) or '')

    def _tigetstr(self, cap_name):
        # String capabilities can include "delays" of the form "$<2>".
        # For any modern terminal, we should be able to just ignore
        # these, so strip them out.
        import curses
        cap = curses.tigetstr(cap_name) or ''
        return re.sub(r'\$<\d+>[/*]?', '', cap)

    def render(self, template):
        """
        Replace each $-substitutions in the given template string with
        the corresponding terminal control string (if it's defined) or
        '' (if it's not).
        """
        return re.sub(r'\$\$|\${\w+}', self._render_sub, template)

    def _render_sub(self, match):
        s = match.group()
        if s == '$$': return s
        else: return getattr(self, s[2:-1])

################################################################################

def getTerminalSize():
    def ioctl_GWINSZ(fd):
        try:
            import fcntl, termios, struct, os
            cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ,
        '1234'))
        except:
            return None
        return cr
    cr = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)
    if not cr:
        try:
            fd = os.open(os.ctermid(), os.O_RDONLY)
            cr = ioctl_GWINSZ(fd)
            os.close(fd)
        except:
            pass
    if not cr:
        try:
            cr = (env['LINES'], env['COLUMNS'])
        except:
            cr = (25, 80)
    return int(cr[1]), int(cr[0])

################################################################################    

class Folder:
    path = ""
    files = []
    
    def __init__(self, path):
        self.path = path
        self.files = []
        
    def __repr__(self):
        return self.path + "/"
    
    def __str__(self):
        return self.path + "/"
    
    def getSummary(self):
        return self.path + " [" + `len(self.files)` + "]"

class FrameSet:
    name = ""
    extension = ""
    folder = ""
    frames = []
    startFrame = ""
    endFrame = ""
    missingFrames = []
    corruptFrames = []
    totalSize = 0

    def __init__(self, name, extension, folder):
        self.name = name
        self.extension = extension
        self.folder = folder
        self.frames = []
        self.startFrame = ""
        self.endFrame = ""
        self.missingFrames= []
        self.missingFramesTotal = ""
        self.corruptFrames = []
        
    def __repr__(self):
        return "Name: " + self.name + "\nExtension: " + self.extension + "\nFrames: " + str(self.frames) + "\nRange: " + self.startFrame + "-" + self.endFrame + "\nMissing Frames: " + `self.missingFrames` + "\nCorrupt Frames: " + `self.corruptFrames`
    
    def __str__(self):
        summary =""
        if (self.corruptFrames != [] or self.missingFrames != []):
            summary += term.RED
        else:
            summary += term.GREEN
        summary += "\n" + self.getNameTemplate() + " [" + self.getTotalRange() + "]"
        summary += "\n" + str(self.folder) + term.NORMAL
        if (self.missingFrames != []):
            summary += "\n   Missing Frames: Total-" + `self.missingFramesTotal` + " " + `self.missingFrames`
        if (self.corruptFrames != []):
            summary += "\n   Corrupt Frames: " + `genFrameRanges(self.corruptFrames)` 
        summary += "\n   Frames: " + `len(self.frames)` +\
            "\n   Duration@29.97fps: " + self.getDuration() +\
            "\n   Size: " + self.getReadableSize()
        summary += "\n"
        return summary
        
    def getNameTemplate(self):
        return self.name + ('#' * self.getPadLength()) + self.extension
    
    def getTotalRange(self):
        return self.startFrame + "-" + self.endFrame
        
    def getPadLength(self):
        return len(self.frames[0])
        
    def getReadableSize(self):
        if self.totalSize >= 1073741824:
            return str(self.totalSize / 1024 / 1024 / 1024) + ' GB'
        elif bytes >= 1048576:
            return str(self.totalSize / 1024 / 1024) + ' MB'
        elif bytes >= 1024:
            return str(self.totalSize / 1024) + ' KB'
        elif bytes < 1024:
            return str(self.totalSize) + ' bytes'
            
    def getDuration(self):
        rate = 29.97
        frames = (int(self.endFrame) - int(self.startFrame))
        dHours = padFrame(frames // (60*60*rate), 2)
        dMinutes = padFrame((frames // (60*rate)) % 60, 2)
        dSeconds = padFrame(((frames // (rate)) % 60) % 60, 2)
        dFrames = padFrame(frames % rate % 60 % 60, 2)
        duration = dHours + ";" + dMinutes + ";" + dSeconds + ";" + dFrames
        return duration

# Methods
def padFrame(frame,pad):
    frame = int(round(float(frame)))
    return '0' * (pad - len(str(frame))) + str(frame)

def genFrameRanges(frames):
    i = 0
    frameRanges = []
    frames.sort()
    if (len(frames) > 0):
        while(i+1 <= len(frames)):
            rangeStart = frames[i]
            # If there is another value in the array to check,
            # check if it's a consecutive frame
            while(i+2 <= len(frames)):
                if (int(frames[i]) + 1 != int(frames[i+1])):
                    break
                else:
                    i = i+1
            # If it's a range return as #-# otherwise just return the #
            if (rangeStart != frames[i]):
                rng = str(padFrame(rangeStart, seqData.currFS.getPadLength())) + "-" + str(padFrame(frames[i], seqData.currFS.getPadLength()))
                frameRanges.append(rng)
            else:
                rng = str(padFrame(rangeStart, seqData.currFS.getPadLength()))
                frameRanges.append(rng)
            i = i+1
    return frameRanges

def checkMissingFrames(frameSet):
    start = int(frameSet.startFrame)
    end = int(frameSet.endFrame)
    
    pad = len(frameSet.frames[0])
    idealRange = set(range(start, end + 1))
    actualRange = set([int(frame) for frame in frameSet.frames])
    # sets can't be sorted, so cast to a list here
    missingFrames = list(idealRange - actualRange)
    missingFrames.sort()
    
    frameSet.missingFrames = genFrameRanges(missingFrames)
    frameSet.missingFramesTotal = len(missingFrames)

# Go through each file and check the file size. If it's an image, make sure its not corrupt.
def checkFrameSize(frameSet):    
    # Create a progress bar
    p = ProgressBar(len(frameSet.frames))
    p.fill_char = '='
    p.msg = "Checking " + frameSet.name + " "
    sys.stdout.flush()
    
    corruptFrames = []
    totalSize = 0
    i = 1
    for frame in frameSet.frames:
        try:
            filePath = str(frameSet.folder) + frameSet.name + frame + frameSet.extension
            fileSize = os.path.getsize(filePath)
            totalSize += fileSize

            # If frameSet includes images, make sure they aren't corrupt
            if (isImage(frameSet.extension) and isImageCorrupt(filePath)):
                corruptFrames.append(frame)
        except Exception,e:
            print "ERROR: Unable to check size of " + filePath
        p.update_time(i)
        sys.stdout.flush()
        i = i+1

    frameSet.corruptFrames = corruptFrames
    frameSet.totalSize = totalSize

    p.clear_progress()
    sys.stdout.flush()
    del p


# Check if the frame set includes images
def isImage(extension):
    result = False
    validFormats = ['bmp', 'bufr', 'cur', 'dcx', 'eps', 'fits', 'fli', 'flc', 'fpx', 'gbr', 'gd', 'gif', 'grib', 'hdf5', 'ico', 'im',  'imt', 'jpg', 'jpeg', 'mic', 'mpg', 'mpeg', 'msp', 'palm', 'pcd', 'pcx', 'pdf', 'pixar', 'png', 'ppm', 'psd', 'sgi', 'tga', 'targa', 'tiff', 'tif', 'wal', 'wmf', 'xbm', 'xpm']
    for format in validFormats:
        if (extension.lower() == ("." + format)):
            result = True
    
    return result

# Check if an image is valid or corrupt
def isImageCorrupt(file):
    try:
        if (testIfValid):
            img = Image.open(file)
        return False
    except:
        return True


# Main Method of checking frames
def checkFrames():
    for frameSet in seqData.frameSets:
        checkMissingFrames(frameSet)
        checkFrameSize(frameSet) # Includes progress bar
        print str(frameSet)
    
def findFrameSet(name, folder):
    currFS = ""

    for frameSet in seqData.frameSets:
        if (frameSet.name == name and frameSet.folder == folder):
            currFS = frameSet
    
    return currFS

def deleteFrames(framesToDel, deleteAll=False, corrupt=False):
    selFrameSets = []

    # If deleting all frames, then get the longest frame range
    if (seqData.frameSets == 0):
        print "ERROR: No sequences found."    

    elif (deleteAll == True or corrupt==True):
        selFrameSets = seqData.frameSets

    else:
        # Find which sequence(s) to delete the frames from
        # First check to see if there are multiple frame sets
        if (len(seqData.frameSets) > 1):
            for s in range(0, len(seqData.frameSets)):
                print str(s+1) + ") " + seqData.frameSets[s].getNameTemplate() + " [" + seqData.frameSets[s].getTotalRange() + "]"
            exit = False
            while(exit != True):
                userInput = raw_input("Delete frames from which sequence(s)? ")
                choices = parseNumbers(userInput, numRange=range(1, len(seqData.frameSets)))
                if (userInput == ""):
                    exit = True
                elif (choices != ""):
                    for choice in choices:
                        selFrameSets.append(seqData.frameSets[choice-1])
                        exit = True
        elif (len(seqData.frameSets) == 1):
            selFrameSets.append(seqData.frameSets[0])

        
    if (len(selFrameSets) > 0):
        # Get the total number of frames to delete
        totalFramesToDel = 0
        if (deleteAll == True):
            for frameSet in selFrameSets:
                totalFramesToDel += len(frameSet.frames)
        elif (corrupt == True):
            for frameSet in selFrameSets:
                totalFramesToDel += len(frameSet.corruptFrames)
        else:
            totalFramesToDel = len(framesToDel) * len(selFrameSets)

        # Create a progress bar
        p = ProgressBar(totalFramesToDel)
        p.fill_char = '='
        p.msg = "Deleting Frames "
        sys.stdout.flush()
        errors = [] # Store Errors to print later so the progress bar isn't messed up
        
        # For each frameSet selected, delete the frames
        i = int(0)
        for frameSet in selFrameSets:
            if (deleteAll == True):
                framesToDel = frameSet.frames
            elif (corrupt == True):
                framesToDel = frameSet.corruptFrames
            for frameToDel in framesToDel:
                filepath = str(frameSet.folder) + frameSet.name + padFrame(frameToDel, frameSet.getPadLength()) + frameSet.extension
                exist = False
                try:
                    exist = os.path.exists(filepath)
                    os.remove(filepath)
                except Exception, e:
                    print e
                    if (exist == True):
                        errors.append(str(frameToDel))
                p.update_time(i)
                sys.stdout.flush()
                i = i+1
        
        p.clear_progress()
        sys.stdout.flush()
        
        del p

        print "Deleted " + str(totalFramesToDel - len(errors)) + " Frames!"
        
        if (len(errors) > 0):
            print "ERROR: Unable to delete " + str(len(errors)) + " frames. " + str(genFrameRanges(errors))
            exit(os.EX_OSERR) # General Error


# Parse a comma separated list of numbers
def parseNumbers(numbers, numRange=[]):
    numbers = str(numbers)
    pattern = re.compile('[0-9,-]')
    possibles = ""

    error = False
    if (numbers == ""):
        print "ERROR: No input number(s) given"
        return ""

    if (len(pattern.findall(numbers)) == len(numbers)):
        possibles = str(numbers).split(",")
        numbers = []
        error = False

        for possible in possibles:
            if "-" in possible:
                values = possible.split("-")
                if (len(values) == 2):
                    newRange = range(int(values[0]), int(values[1])+1)
                    numbers.extend(newRange)
                else:
                    print "ERROR: Invalid Range (" + str(possible) + ")"
                    error = True
                    break
            else:
                numbers.append(int(possible))

        # If a range was specified, make sure all the numbers are in that range
        if (numRange != []):
            possibles = numbers
            numbers = []
            for possible in possibles:
                if (possible in numRange):
                    numbers.append(possible)
                else:
                    print "ERROR: Invalid number (" + str(possible) + "), out of range [" + str(numRange[0]) + "," + str(numRange[-1]) + "]"
                    error = True
                    break

        if error is False:
            #  Remove Duplicates and sort the numbers
            numbers = sorted(set(numbers))
            return numbers
        else:
            return ""
    else:
        print "ERROR: Invalid input numbers."
        exit(os.EX_USAGE) # Command was input incorrectly  
        return ""
                
            
##############################################################################################
# Main
##############################################################################################

def loadToFolder(root, name):
    found = False
    for folder in seqData.folders:
        if (root == folder.path):
            folder.files.append(name)
            found = True

    if (found == False):
        seqData.folders.append(Folder(root))

def main(recursive=False):

    seqData.folders = []
    seqData.frameSets = []

    # Add the original folder as the first item in the folder array
    topDir = os.path.dirname(seqData.directory) + "/" + os.path.basename(seqData.directory) + "/"
    seqData.folders.append(Folder(topDir))
    
    # If a recursive folder search is true, get the names and paths of the subdirectories
    msg = "Searching for frames..."
    if (recursive == False):
        seqData.folders[0].files = os.listdir(seqData.directory)
    else:
        currDir = ""
        for root, dirs, files in os.walk(topDir):
            for name in files:
                loadToFolder(str(root), str(name))
                sys.stdout.write("\r" + (' ' * 60) + "\r" + "Searching for frames..." + name)
                sys.stdout.flush()

    sys.stdout.write('\r' + (' ' * 60) + '\r')
    sys.stdout.flush()
    
    # For each folder in the folder array, load the frames
    for folder in seqData.folders:
        seqData.currFolder = folder
        loadFrames()

def loadFrames():
    global seqData

    sys.stdout.write("Loading Frames...")
    sys.stdout.flush()

    # Image sequence Pattern
    pattern = re.compile('(.+?)(\d\d+?)(\.\w+)')
    matches = pattern.finditer('\n'.join(seqData.currFolder.files))

    for match in matches:
            name, number, extension  = match.groups()
            
            # If there aren't any frame sets yet
            if (len(seqData.frameSets) == 0):
                seqData.frameSets.append(FrameSet(name, extension, seqData.currFolder))
                seqData.currFS = seqData.frameSets[len(seqData.frameSets)-1]
            else:
            # Check if there is a frame set already created with the same name and folder
                seqData.currFS = findFrameSet(name, seqData.currFolder)
                # Create a new frame set since it doesn't already exist
                if (seqData.currFS == ""):
                    seqData.frameSets.append(FrameSet(name, extension, seqData.currFolder))
                    seqData.currFS = seqData.frameSets[len(seqData.frameSets)-1]
            
            # Add the frame to the current frame set
            seqData.currFS.frames.append(number)
        
            if (len(seqData.currFS.frames) == 1):
                seqData.currFS.startFrame = number
                seqData.currFS.endFrame = number
            elif (int(number) > seqData.currFS.startFrame):
                seqData.currFS.startFrame = number
            elif (int(number) < seqData.currFS.endFrame):
                seqData.currFS.endFrame = number
    
    sys.stdout.write('\r' + (' ' * 30) + '\r')
    sys.stdout.flush()

# Setup the command line options
usage = "usage: %prog [options] arg - Sequence Utiliy v1.0"
description = "Scans current directory for image sequences. You can then gather information about each image sequence or delete frames. If the terminal supports it, the valid sequences are displayed in green, and invalid sequences in red."
parser = OptionParser(usage, description=description)

# Check Frames
parser.add_option("-i", "--info", action="store_true", help="Gather information about the image sequences including missing or corrupt frames.",
    dest="check", default=False)

parser.add_option("-V", "--valid", action="store_true", help="Check whether images are valid.",
    dest="valid", default=False)

parser.add_option("-d", "--delete", action="store", help="Delete all frames, those in a list, or corrupt frames.",
    dest="delete", default="", metavar="1,3-5,110 or ALL or CORRUPT")

parser.add_option("-r", "--recursive", action="store_true", help="Also include sequences found any sub folders.",
    dest="recursive", default=False)

# Parse the given arguments
(options, args) = parser.parse_args()

term = TerminalController()

testIfValid = False

while(True):

    searchDirectory = os.getcwd()
    if (len(args) != 0):
        if (os.path.exists(args[0])):
            searchDirectory = args[0]
        else:
            print "ERROR: Invalid input location."
            exit(os.EX_OSFILE) # Exited due to folder not existing

    seqData = SeqData(searchDirectory)

    # First delete the frames requested
    if (options.delete != ""):
    
        # Get rid of any quotations or spaces
        options.delete = options.delete.replace("\"", "").replace(" ", "")
    
        main(options.recursive)
        if (options.delete.upper() == "ALL"):
            deleteFrames([0], deleteAll=True)    
        elif (options.delete.upper() == "CORRUPT"):
            checkFrames()
            deleteFrames([0], corrupt=True)
        else:
            frames = parseNumbers(options.delete)
            if (frames != ""):
                deleteFrames(frames)                

    # Test if check frames was selected
    if (options.check):
        main(options.recursive)
        if (options.valid):
            testIfValid = True
        checkFrames()        
    
    if options.check is False and (options.delete == ""):
        parser.print_help()
    
    exit(os.EX_OK) # Exited Correctly
    