// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------// Elevate Qube Submission Prep Script// Author: Brennan Chapman// Version: 1.0// Date: 4/8/2011//// Gathers all of the relevate info about a project into a JSON object.// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------// #include '/Volumes/theGrill/Resource_Library/Art_Anim/Scripts/After_Effects/getDataFile.jsx';// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------// Qube Functions// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------function getQubeguiPath(){    var qubeguiPath = "";    // Get from preferences    if (app.settings.haveSetting("Qube", "QubeGUI_path")) {        qubeguiPath = app.settings.getSetting("Qube", "QubeGUI_path");    }     // if path invalid, then prompt for path    var qubeguiFile = new File(qubeguiPath);    if (!qubeguiFile.exists) {        qubeguiPath = setQubeguiPath()    }    writeLn("QubeGUI path: "+qubeguiPath);    return qubeguiPath;}// See same function in Qube_SetPath.jsxfunction setQubeguiPath(){    var qubeguiPath = "";    // if not have QubeGUI path, then open dialog to browse to it    if (system.osName == "MacOS") { // note: using a prompt since the MacOS filebrowser cannot seem to select .app files        qubeguiPath = prompt("Enter the path to the QubeGUI", "/Applications/pfx/qube/qube.app");        // (For OSX) if selected app ends with .app, then append the part internal to the app        if (qubeguiPath.indexOf('.app') == qubeguiPath.length - 4) { // if .app at end            qubeguiPath += '/Contents/MacOS/qube';        }    }    else {        var qubeguiPathObj = File.openDialog("Enter the path to the QubeGUI", "");        if (qubeguiPathObj != null) {            qubeguiPath = qubeguiPathObj.fsName;        }    }    if (qubeguiPath != "") {        alert("Storing 'QubeGUI_path' as '"+qubeguiPath+"'");        app.settings.saveSetting("Qube", "QubeGUI_path", qubeguiPath);    }    return qubeguiPath;}// Check for potential conflictsfunction checkProj() {    var errors, warnings, rq, queued;    errors = [];    warnings = [];    rq = app.project.renderQueue;    queued = 0;    // Make sure there are items in the render queue    if (app.project.renderQueue.numItems < 1) {        errors[errors.length] = "ERROR: No items to render in the render queue.";    }    for (var r=1; r<=app.project.renderQueue.items.length; r++) {        var frameRate, startTime, duration, stopTime, compDuration;        // Gather data to use w        frameRate = rq.items[r].comp.frameRate.toFixed(2);        startTime = parseFloat(timeToCurrentFormat(rq.items[r].timeSpanStart, frameRate)).toFixed(0);        duration = parseFloat(timeToCurrentFormat(rq.items[r].timeSpanDuration, frameRate)).toFixed(0);        stopTime = parseFloat(parseInt(startTime) + parseInt(duration));        compDuration = parseFloat(timeToCurrentFormat(rq.items[r].comp.duration, rq.items[r].comp.frameRate)).toFixed(0);        status = rq.items[r].status;                $.writeln("status: " + status);        if ( status == RQItemStatus.QUEUED ) {            queued++;        }        // Check if rendering the work area or the full comp        if (startTime != 0 || stopTime < compDuration) {            warnings[warnings.length] = "WARNING: RQ Item " + r + " only rendering the work area (" + startTime + "-" + stopTime + ")";        }    }    $.writeln("Queued: " + queued);    if (queued == 0) {        errors[errors.length] = "ERROR: No Items queued to render";    }    if (errors.length > 0) {        alert("Qube Submit Errors\n" + errors.join("\n"), "Errors", true);        return false;    } ;    if (warnings.length > 0) {        if (confirm("Warnings\n" + warnings.join("\n"), false, "Warnings") == false) {            return false;        }    } ;    return true;}function sendToQube() {    var qubeguiPath = getQubeguiPath();        // Submit each queue rq item separately    var rq = app.project.renderQueue;	var rqi;	// the items are indexed from 1 to numItems.    for (var i = rq.numItems; i >= 1; i--) {        var args, cmd, cmdOutput;        rqi = rq.item(i);        if (rqi.status == RQItemStatus.QUEUED ) {  // alt?: cur_item.render == true            // status options: QUEUED, UNQUEUED, NEEDS_OUTPUT, WILL_CONTINUE            // construct commands            $.writeln("test");            args = " --submitDict \"{"+                                "'prototype':'Submit After Effects', "+                                "'name':'" + proj.file.fsName + "',"+                                "'package':{"+                                    "'simpleCmdType':'Submit After Effects',"+                                    "'projectPath':'"+proj.file.fsName+"',"+                                    "'rqIndex':'" + i + "',"+                                "}}\"";            cmd = "";            if (system.osName == "MacOS") {                cmd = qubeguiPath + args + " >& /dev/null &";            }            else {                cmd = "\"" + qubeguiPath + "\"" + args;  // NOTE: using "start" does not work here            }            writeLn(cmd);            $.writeln(cmd);            cmdOutput = system.callSystem(cmd);            writeLn(cmdOutput);        }    }}// Go!if (app.project.file == null) {    alert("ERROR: Unable send to Qube. Please Save Project First.");} else {    var go, currTimeFormat;        // Switch the timecode type to frames    currTimeFormat = app.project.timecodeDisplayType;    app.project.timecodeDisplayType = TimecodeDisplayType.FRAMES;            go = checkProj();        if (go) {        Qube.makeDataFile();        sendToQube();    } else {        clearOutput();        writeLn("Submission Cancelled.")    }        // Switch the timecode type back to original format    app.project.timecodeDisplayType = currTimeFormat;}